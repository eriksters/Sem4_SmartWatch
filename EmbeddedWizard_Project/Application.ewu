$version 9.30

// This is the root component of the entire GUI application.
$rect <20,20,220,60>
$output false
class Application : Core::Root
{
  $rect <820,0,1020,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <820,40,1020,80>
  inherited method Init()
  {
    var Application::ClockDialog clkDialog = new Application::ClockDialog;

    PresentDialog(clkDialog, null, null, null, null, null, null, null, null, false);
  }

  // To do:
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widgets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <10,500,790,700>;
  }
}

// This is a font resource.
$rect <30,360,230,400>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Arial;
  attr fontheight Height = 32;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <30,230,230,270>
$output false
class ClockComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,600,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text TextHour
  {
    preset Bounds = <0,0,200,200>;
    preset String = "20";
    preset Font = Application::ClockFont;
  }

  $rect <20,20,160,60>
  object Views::Text TextMinute
  {
    preset Bounds = <200,0,400,200>;
    preset String = "20";
    preset Font = Application::ClockFont;
  }

  $rect <20,20,160,60>
  object Views::Text TextSecond
  {
    preset Bounds = <400,0,600,200>;
    preset String = "20";
    preset Font = Application::ClockFont;
  }

  $rect <20,20,160,60>
  object Views::Text Colon1
  {
    preset Bounds = <180,0,220,180>;
    preset String = ":";
    preset Font = Application::ClockFont;
  }

  $rect <20,20,160,60>
  object Views::Text Colon2
  {
    preset Bounds = <380,0,420,180>;
    preset String = ":";
    preset Font = Application::ClockFont;
  }

  $rect <290,230,490,270>
  method uint8 SetHour( arg uint8 hour )
  {
    var string toSet;

    if (hour > 24) {
      return 1;
    }

    if (hour < 10) {
      toSet = "0" + (string) hour;
    } else {
      toSet = (string) hour;
    }

    TextHour.String = toSet;

    return 0;
  }

  $rect <290,270,490,310>
  method uint8 SetMinute( arg uint8 minute )
  {
    var string toSet;

    if (minute > 59) {
      return 1;
    }

    if (minute < 10) {
      toSet = "0" + (string) minute;
    } else {
      toSet = (string) minute;
    }

    TextMinute.String = toSet;  
    return 0;
  }

  $rect <290,310,490,350>
  method uint8 SetSecond( arg uint8 second )
  {
    var string toSet;

    if (second > 59) {
      return 1;
    }

    if (second < 10) {
      toSet = "0" + (string) second;
    } else {
      toSet = (string) second;
    }

    TextSecond.String = toSet;  
    return 0;

  }
}

$rect <30,270,230,310>
$output false
class DateComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,240,140>;

  $rect <240,370,440,410>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <240,330,440,370>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text TextDate
  {
    preset Bounds = <0,0,100,140>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "15";
    preset Font = Application::DateFont;
  }

  $rect <20,20,160,60>
  object Views::Text TextMonth
  {
    preset Bounds = <130,0,240,140>;
    preset String = "04";
    preset Font = Application::DateFont;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <110,0,140,140>;
    preset String = "/";
    preset Font = Application::DateFont;
  }

  $rect <250,230,450,270>
  method uint8 SetDate( arg uint8 date )
  {
    if (date < 1 || date > 31) {
      return 1;
    }

    TextDate.String = (string) date;
    return 0;


  }

  $rect <250,270,450,310>
  method uint8 SetMonth( arg uint8 month )
  {
    var string toSet;

    if (month < 1 || month > 12) {
      return 1;
    }

    if (month < 10) {
      toSet = "0" + (string) month;
    } else {
      toSet = (string) month;
    }

    TextMonth.String = toSet;
    return 0;
  }
}

$rect <30,400,230,440>
$output false
resource Resources::Font ClockFont
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 150;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <30,440,230,480>
$output false
resource Resources::Font DateFont
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 90;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

// Resources

note group Note
{
  attr Bounds = <20,330,500,490>;
}

// Components
note group Note1
{
  attr Bounds = <20,200,500,320>;
}

// Dialogs
note group Note2
{
  attr Bounds = <20,110,500,190>;
}

$rect <30,140,230,180>
$output false
class ClockDialog : Core::Group
{
  $rect <810,0,1010,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <810,240,1010,280>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <810,200,1010,240>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Application::ClockComponent ClockComponent
  {
    preset Bounds = <90,80,690,280>;
  }

  $rect <0,600,200,640>
  object Core::Timer Timer
  {
    preset OnTrigger = TimerSlot;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <0,640,200,680>
  slot TimerSlot
  {
    UpdateClock();
  }

  $rect <20,20,160,60>
  object Application::DateComponent DateComponent
  {
    preset Bounds = <280,240,510,380>;
  }

  $rect <0,490,200,530>
  slot UpdateSlot
  {
    sender; /* the method is called from the sender object */

    //UpdateDialog = new Application::UpdateClockDialog;
    //UpdateDialog.CloseSlot = CloseUpdateDialogSlot;

    //PresentDialog(UpdateDialog, null, null, null, null, null, null, null, null, false);
  }

  $rect <380,620,580,660>
  method void UpdateClock()
  {
    var Application::DateTime dt = Application::Device.getDateTime();

    ClockComponent.SetHour( dt.Hour );
    ClockComponent.SetMinute( dt.Minute );
    ClockComponent.SetSecond( dt.Second );

    DateComponent.SetDate( dt.Date );
    DateComponent.SetMonth( dt.Month );
  }

  $rect <0,530,200,570>
  slot CloseUpdateDialogSlot
  {
    //DismissDialog(UpdateDialog, null, null, null, null, null, false);
  }

  // 100 ms timer for getting clock and date updates
  note legend Note
  {
    attr Bounds = <200,600,380,680>;
  }
}

// Device interface
note group Note3
{
  attr Bounds = <530,110,750,240>;
}

$rect <540,150,740,190>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <40,30,240,70>
  method Application::DateTime getDateTime()
  {
    var Application::DateTime dt = new Application::DateTime;

    $if (!$prototyper)
    native (dt)
    {
      extern void clock_getDateTime( ApplicationDateTime );

      clock_getDateTime( dt );
    }
    $else
    dt.Date = 1;
    dt.WeekDay = 5;
    dt.Month = 5;
    dt.Hour = 8;
    dt.Minute = 44;
    dt.Second = 50;
    $endif

    return dt;

  }
}

$rect <540,190,740,230>
autoobject Application::DeviceClass Device;

// Data classes
note group Note4
{
  attr Bounds = <530,250,750,340>;
}

$rect <540,290,740,330>
class DateTime
{
  $rect <0,0,200,40>
  property uint8 Month;

  $rect <0,40,200,80>
  $output true
  property uint8 WeekDay;

  $rect <0,80,200,120>
  property uint8 Date;

  $rect <220,0,420,40>
  property uint8 Hour;

  $rect <220,40,420,80>
  property uint8 Minute;

  $rect <220,80,420,120>
  property uint8 Second;
}
