$version 9.30

// This is the root component of the entire GUI application.
$rect <20,20,220,60>
class Application : Core::Root
{
  $rect <820,0,1020,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <820,40,1020,80>
  inherited method Init()
  {
    dialogArray[0] = new Application::ClockDialog;
    dialogArray[1] = new Application::HeartRateDialog;

    SwitchToDialog( dialogArray[activeDialogIndex], null, null, null, null, null, null, null, null, null, false );

  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,800,480>;
    preset Bitmap = Application::Background;
  }

  $rect <0,490,200,530>
  array Core::Group dialogArray[ 2 ];

  $rect <0,530,200,570>
  var int32 activeDialogIndex = 0;

  $rect <240,490,440,530>
  slot WipeRightHandler
  {
    trace "Swipe right";

    activeDialogIndex = activeDialogIndex - 1;
    if (activeDialogIndex < 0) {
      activeDialogIndex = dialogArray.size - 1;
    }

    SwitchToDialog( dialogArray[activeDialogIndex], Effects::SlideRightCentered, null, null, null, Effects::SlideRightCentered, null, null, null, null, false);
  }

  $rect <240,530,440,570>
  slot WipeLeftHandler
  {
    trace "Swipe left";

    activeDialogIndex = activeDialogIndex + 1;
    if (activeDialogIndex > dialogArray.size - 1) {
      activeDialogIndex = 0;
    }

    SwitchToDialog( dialogArray[activeDialogIndex], Effects::SlideLeftCentered, null, null, null, Effects::SlideLeftCentered, null, null, null, null, false);
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,480>;
    preset OnRight = WipeRightHandler;
    preset OnLeft = WipeLeftHandler;
  }
}

// This is a font resource.
$rect <30,560,230,600>
$output false
resource Resources::Font Font
{
  attr fontname FontName = Arial;
  attr fontheight Height = 32;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <30,320,230,360>
class ClockComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,600,200>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text TextHour
  {
    preset Bounds = <0,0,200,200>;
    preset String = "20";
    preset Font = Application::ClockFont;
  }

  $rect <20,20,160,60>
  object Views::Text TextMinute
  {
    preset Bounds = <200,0,400,200>;
    preset String = "20";
    preset Font = Application::ClockFont;
  }

  $rect <20,20,160,60>
  object Views::Text TextSecond
  {
    preset Bounds = <400,0,600,200>;
    preset String = "20";
    preset Font = Application::ClockFont;
  }

  $rect <20,20,160,60>
  object Views::Text Colon1
  {
    preset Bounds = <180,0,220,180>;
    preset String = ":";
    preset Font = Application::ClockFont;
  }

  $rect <20,20,160,60>
  object Views::Text Colon2
  {
    preset Bounds = <380,0,420,180>;
    preset String = ":";
    preset Font = Application::ClockFont;
  }

  $rect <290,230,490,270>
  method uint8 SetHour( arg uint8 hour )
  {
    var string toSet;

    if (hour > 24) {
      return 1;
    }

    if (hour < 10) {
      toSet = "0" + (string) hour;
    } else {
      toSet = (string) hour;
    }

    TextHour.String = toSet;

    return 0;
  }

  $rect <290,270,490,310>
  method uint8 SetMinute( arg uint8 minute )
  {
    var string toSet;

    if (minute > 59) {
      return 1;
    }

    if (minute < 10) {
      toSet = "0" + (string) minute;
    } else {
      toSet = (string) minute;
    }

    TextMinute.String = toSet;  
    return 0;
  }

  $rect <290,310,490,350>
  method uint8 SetSecond( arg uint8 second )
  {
    var string toSet;

    if (second > 59) {
      return 1;
    }

    if (second < 10) {
      toSet = "0" + (string) second;
    } else {
      toSet = (string) second;
    }

    TextSecond.String = toSet;  
    return 0;

  }
}

$rect <30,360,230,400>
$output false
class DateComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,240,140>;

  $rect <240,370,440,410>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <240,330,440,370>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Text TextDate
  {
    preset Bounds = <0,0,100,140>;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "15";
    preset Font = Application::DateFont;
  }

  $rect <20,20,160,60>
  object Views::Text TextMonth
  {
    preset Bounds = <130,0,240,140>;
    preset String = "04";
    preset Font = Application::DateFont;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <110,0,140,140>;
    preset String = "/";
    preset Font = Application::DateFont;
  }

  $rect <250,230,450,270>
  method uint8 SetDate( arg uint8 date )
  {
    if (date < 1 || date > 31) {
      return 1;
    }

    TextDate.String = (string) date;
    return 0;


  }

  $rect <250,270,450,310>
  method uint8 SetMonth( arg uint8 month )
  {
    var string toSet;

    if (month < 1 || month > 12) {
      return 1;
    }

    if (month < 10) {
      toSet = "0" + (string) month;
    } else {
      toSet = (string) month;
    }

    TextMonth.String = toSet;
    return 0;
  }
}

$rect <30,600,230,640>
$output false
resource Resources::Font ClockFont
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 150;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <30,640,230,680>
$output false
resource Resources::Font DateFont
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 90;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

// Resources
note group Note
{
  attr Bounds = <20,530,440,780>;
}

// Components
note group Note1
{
  attr Bounds = <20,290,440,520>;
}

// Dialogs
note group Note2
{
  attr Bounds = <20,110,440,280>;
}

$rect <30,140,230,180>
$output false
class ClockDialog : Core::Group
{
  $rect <810,0,1010,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <810,240,1010,280>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <810,200,1010,240>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Application::ClockComponent ClockComponent
  {
    preset Bounds = <90,80,690,280>;
  }

  $rect <0,600,200,640>
  object Core::Timer Timer
  {
    preset OnTrigger = TimerSlot;
    preset Period = 100;
    preset Enabled = true;
  }

  $rect <0,640,200,680>
  slot TimerSlot
  {
    UpdateClock();
  }

  $rect <20,20,160,60>
  object Application::DateComponent DateComponent
  {
    preset Bounds = <280,240,510,380>;
  }

  $rect <380,620,580,660>
  method void UpdateClock()
  {
    var Application::DateTime dt = Application::Device.getDateTime();

    ClockComponent.SetHour( dt.Hour );
    ClockComponent.SetMinute( dt.Minute );
    ClockComponent.SetSecond( dt.Second );

    DateComponent.SetDate( dt.Date );
    DateComponent.SetMonth( dt.Month );
  }

  // 100 ms timer for getting clock and date updates
  note legend Note
  {
    attr Bounds = <200,600,380,680>;
  }

  $rect <10,490,210,530>
  slot UpdateSlot
  {
    sender; /* the method is called from the sender object */

    UpdateDialog = new Application::UpdateClockDialog;
    UpdateDialog.CloseSlot = CloseUpdateDialogSlot;

    PresentDialog(UpdateDialog, null, null, null, null, null, null, null, null, false);
  }

  $rect <10,530,210,570>
  slot CloseUpdateDialogSlot
  {
    DismissDialog(UpdateDialog, null, null, null, null, null, false);
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,380,210,480>;
    preset OnPress = UpdateSlot;
    preset Label = "Update";
    preset Appearance = WidgetSet::PushButton_Large;
  }

  $rect <270,490,470,530>
  var Application::UpdateClockDialog UpdateDialog;
}

// Device interface
note group Note3
{
  attr Bounds = <530,110,750,240>;
}

$rect <540,150,740,190>
class DeviceClass : Templates::DeviceClass
{
  $rect <40,30,240,70>
  method Application::DateTime getDateTime()
  {
    var Application::DateTime dt = new Application::DateTime;

    $if (!$prototyper)
    native (dt)
    {
      extern void clock_getDateTime( ApplicationDateTime );

      clock_getDateTime( dt );
    }
    $else
    dt.Date = 1;
    dt.WeekDay = 5;
    dt.Month = 5;
    dt.Hour = 8;
    dt.Minute = 44;
    dt.Second = 50;
    $endif

    return dt;

  }

  $rect <40,70,240,110>
  method void setDateTime( arg Application::DateTime dt )
  {
    $if(!$prototyper)
    native (dt)
    {
      extern void clock_setDateTime( ApplicationDateTime );

      clock_setDateTime(dt);
    }
    $endif
  }

  $rect <40,150,240,190>
  method int32 getHeartRate()
  {
    var int32 heartRate = 0;

    $if (!$prototyper)
    native (heartRate)
    {
      extern signed int heartRate_getHeartRate( void );

      heartRate = heartRate_getHeartRate();
    }
    $else
    heartRate = 80;
    $endif

    return heartRate;
  }
}

$rect <540,190,740,230>
autoobject Application::DeviceClass Device;

// Data classes
note group Note4
{
  attr Bounds = <530,250,750,340>;
}

$rect <540,290,740,330>
class DateTime
{
  $rect <0,0,200,40>
  $output true
  property uint8 Month;

  $rect <0,40,200,80>
  $output true
  property uint8 WeekDay;

  $rect <0,80,200,120>
  $output true
  property uint8 Date;

  $rect <220,0,420,40>
  $output true
  property uint8 Hour;

  $rect <220,40,420,80>
  $output true
  property uint8 Minute;

  $rect <220,80,420,120>
  $output true
  property uint8 Second;
}

$rect <230,140,430,180>
$output false
class UpdateClockDialog : Core::Group
{
  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,480>;
    preset Color = #000000E0;
  }

  $rect <30,520,230,560>
  inherited property Bounds = <0,0,800,480>;

  $rect <30,610,230,650>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <30,570,230,610>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <810,0,1010,40>
  inherited method Init()
  {
    var Application::DateTime dt = Application::Device.getDateTime();

    Hour = dt.Hour;
    Minute = dt.Minute;
    Second = dt.Second;

    Date = dt.Date;
    Month = dt.Month;

    DateComponent.SetDate( dt.Date );
    DateComponent.SetMonth( dt.Month );

    ClockComponent.SetHour( dt.Hour );
    ClockComponent.SetMinute( dt.Minute );
    ClockComponent.SetSecond( dt.Second );
  }

  $rect <20,20,160,60>
  object Application::ClockComponent ClockComponent
  {
    preset Bounds = <-10,100,580,310>;
  }

  $rect <20,20,160,60>
  object Application::DateComponent DateComponent
  {
    preset Bounds = <560,140,800,280>;
  }

  // This autoobject provides the default customization for the 'push button' widget \
  // (WidgetSet::PushButton) in its large size variant.
  $rect <1430,60,1730,100>
  object WidgetSet::PushButtonConfig PushButton_Large
  {
    preset LabelColorActive = #FFFFFFFF;
    preset LabelColorFocused = #FFFFFFFF;
    preset LabelColorDisabled = #A8ABABFF;
    preset LabelColorDefault = #6C6E70FF;
    preset LabelMarginBottom = 9;
    preset LabelMarginTop = 9;
    preset LabelMarginRight = 9;
    preset LabelMarginLeft = 9;
    preset IconTintDisabled = #A8ABABAA;
    preset IconTintDefault = #6C6E70FF;
    preset IconMarginBottom = 9;
    preset IconMarginTop = 9;
    preset IconMarginRight = 9;
    preset IconMarginLeft = 9;
    preset LabelFont = Resources::FontLarge;
    preset FaceFrameActive = 3;
    preset FaceFrameFocused = 2;
    preset FaceFrameDisabled = 0;
    preset FaceFrameDefault = 1;
    preset FaceActive = WidgetSet::PushButtonLarge;
    preset FaceFocused = WidgetSet::PushButtonLarge;
    preset FaceDisabled = WidgetSet::PushButtonLarge;
    preset FaceDefault = WidgetSet::PushButtonLarge;
    preset WidgetMinSize = <51,51>;
  }

  $rect <20,20,160,60>
  object Application::PushButtonArr PushButtonArr
  {
    preset Bounds = <20,30,160,140>;
    preset OnPress = HourUpSlot;
  }

  $rect <20,20,160,60>
  object Application::PushButtonArr PushButtonArr1
  {
    preset Bounds = <220,30,360,140>;
    preset OnPress = MinuteUpSlot;
  }

  $rect <20,20,160,60>
  object Application::PushButtonArr PushButtonArr2
  {
    preset Bounds = <420,30,560,140>;
    preset OnPress = SecondUpSlot;
  }

  $rect <20,20,160,60>
  object Application::PushButtonArr PushButtonArr3
  {
    preset Bounds = <20,260,160,370>;
    preset direction = 2;
    preset OnPress = HourDownSlot;
  }

  $rect <20,20,160,60>
  object Application::PushButtonArr PushButtonArr4
  {
    preset Bounds = <220,260,360,370>;
    preset direction = 2;
    preset OnPress = MinuteDownSlot;
  }

  $rect <20,20,160,60>
  object Application::PushButtonArr PushButtonArr5
  {
    preset Bounds = <420,260,560,370>;
    preset direction = 2;
    preset OnPress = SecondDownSlot;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SaveButton
  {
    preset Bounds = <0,380,400,480>;
    preset OnPress = SaveButtonSlot;
    preset Label = "Save";
    preset Appearance = WidgetSet::PushButton_Large;
  }

  $rect <260,520,460,560>
  var uint8 Hour;

  $rect <260,560,460,600>
  var uint8 Minute;

  $rect <260,600,460,640>
  var uint8 Second;

  $rect <470,520,670,560>
  var uint8 Date;

  $rect <470,560,670,600>
  var uint8 Month;

  $rect <30,710,230,750>
  slot HourUpSlot
  {
    sender; /* the method is called from the sender object */

    Hour = Hour + 1;

    if (Hour > 23) {
      Hour = 0;
    }

    ClockComponent.SetHour( (uint8)Hour );
  }

  $rect <250,710,450,750>
  slot MinuteUpSlot
  {
    sender; /* the method is called from the sender object */

    Minute = Minute + 1;

    if (Minute > 59) {
      Minute = 0;
    }

    ClockComponent.SetMinute( (uint8) Minute );
  }

  $rect <470,710,670,750>
  slot SecondUpSlot
  {
    sender; /* the method is called from the sender object */

    Second = Second + 1;

    if (Second > 59) {
      Second = 0;
    }

    ClockComponent.SetSecond( (uint8) Second );
  }

  $rect <30,750,230,790>
  slot HourDownSlot
  {
    sender; /* the method is called from the sender object */

    Hour = Hour - 1;

    if (Hour > 23) {
      Hour = 23;
    }

    ClockComponent.SetHour( (uint8)Hour );
  }

  $rect <250,750,450,790>
  slot MinuteDownSlot
  {
    sender; /* the method is called from the sender object */

    Minute = Minute - 1;

    if (Minute > 59) {
      Minute = 59;
    }

    ClockComponent.SetMinute( (uint8) Minute );
  }

  $rect <470,750,670,790>
  slot SecondDownSlot
  {
    sender; /* the method is called from the sender object */

    Second = Second - 1;

    if (Second > 59) {
      Second = 59;
    }

    ClockComponent.SetSecond( (uint8) Second );
  }

  $rect <720,520,920,560>
  slot SaveButtonSlot
  {
    var Application::DateTime dt = new Application::DateTime;

    dt.Month = Month;
    dt.WeekDay = 1;
    dt.Date = Date;

    dt.Hour = Hour;
    dt.Minute = Minute;
    dt.Second = Second;

    Application::Device.setDateTime( dt );

    signal CloseSlot;
  }

  $rect <720,600,920,640>
  property slot CloseSlot;

  $rect <20,20,160,60>
  object WidgetSet::PushButton CancelButton
  {
    preset Bounds = <400,380,800,480>;
    preset OnPress = CloseButtonSlot;
    preset Label = "Cancel";
    preset Appearance = WidgetSet::PushButton_Large;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <590,50,690,140>;
    preset OnPress = DateUpSlot;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <690,50,790,140>;
    preset OnPress = MonthUpSlot;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <590,260,690,350>;
    preset OnPress = DateDownSlot;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <690,260,790,350>;
    preset OnPress = MonthDownSlot;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <615,71,665,121>;
    preset Bitmap = Resources::NavigationIconsLarge;
  }

  $rect <20,20,160,60>
  object Views::Image Image2
  {
    preset Bounds = <614,280,664,330>;
    preset FrameNumber = 1;
    preset Bitmap = Resources::NavigationIconsLarge;
  }

  $rect <20,20,160,60>
  object Views::Image Image3
  {
    preset Bounds = <715,70,765,120>;
    preset Bitmap = Resources::NavigationIconsLarge;
  }

  $rect <20,20,160,60>
  object Views::Image Image4
  {
    preset Bounds = <716,281,766,331>;
    preset FrameNumber = 1;
    preset Bitmap = Resources::NavigationIconsLarge;
  }

  $rect <30,830,230,870>
  slot DateUpSlot
  {
    sender; /* the method is called from the sender object */

    Date = Date + 1;

    if (Month == 2 && Date > 29) {
      Date = 1;
    }

    if (Date > 31) {
      Date = 1;
    }


    DateComponent.SetDate( (uint8)Date );
  }

  $rect <30,870,230,910>
  slot DateDownSlot
  {
    sender; /* the method is called from the sender object */

    Date = Date - 1;

    if (Date < 1) {
      if (Month == 2) {
        Date = 29;
      } else {
        Date = 31;
      }
    }

    DateComponent.SetDate( (uint8)Date );
  }

  $rect <250,830,450,870>
  slot MonthUpSlot
  {
    sender; /* the method is called from the sender object */

    Month = Month + 1;

    if (Month > 12) {
      Month = 1;
    }

    DateComponent.SetMonth( (uint8)Month );
  }

  $rect <250,870,450,910>
  slot MonthDownSlot
  {
    sender; /* the method is called from the sender object */

    Month = Month - 1;

    if (Month < 1) {
      Month = 12;
    }

    DateComponent.SetMonth( (uint8)Month );
  }

  $rect <720,560,920,600>
  slot CloseButtonSlot
  {
    signal CloseSlot;
  }

  $reorder Rectangle 94
}

$rect <230,320,430,360>
$output false
class PushButtonArr : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,140,110>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if (direction == 1) 
    {
      Arrow.FrameNumber = 3;
    } else if (direction == 2) 
    {
      Arrow.FrameNumber = 1;
    } else if (direction == 3) 
    {
      Arrow.FrameNumber = 2;
    } else 
    {
      Arrow.FrameNumber = 0;
    }

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <10,270,210,310>
  inherited method Init()
  {
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,0,140,110>;
    preset Label = "";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <20,20,160,60>
  object Views::Image Arrow
  {
    preset Bounds = <0,0,140,110>;
    preset Bitmap = Resources::NavigationIconsExtraLarge;
  }

  $rect <240,230,440,270>
  property int32 direction = 0;

  $rect <240,270,440,310>
  onset direction
  {
    // The value doesn't change - nothing to do.
    if ( pure direction == value )
      return;

    // Remember the property's new value.
    pure direction = value;


  }

  $rect <250,350,450,390>
  property slot OnPress;

  $rect <250,390,450,430>
  onset OnPress
  {
    // The value doesn't change - nothing to do.
    if ( pure OnPress == value )
      return;

    // Remember the property's new value.
    pure OnPress = value;
    PushButton.OnPress = OnPress;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <250,430,450,470>
  onget OnPress
  {
    return pure OnPress;
  }
}

$rect <30,180,230,220>
$output false
class HeartRateDialog : Core::Group
{
  $rect <810,0,1010,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <810,80,1010,120>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <810,40,1010,80>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <480,500,790,540>
  object Application::HeartRateDisplayComponent HeartRateDisplayComponent
  {
    preset Bounds = <230,290,580,390>;
  }

  $rect <610,490,810,530>
  var int32 count;

  $rect <0,490,200,530>
  object Core::Timer Timer
  {
    preset OnTrigger = Slot;
    preset Period = 500;
    preset Enabled = true;
  }

  $rect <0,530,200,570>
  slot Slot
  {
    var int32 heartRate;
    $if(!$prototyper)
    heartRate = Application::Device.getHeartRate();
    $else
    heartRate = count;
    count = count + 1;
    $endif

    HeartRateDisplayComponent.SetBPM( heartRate );
  }

  $rect <20,20,160,60>
  object Application::HeartAnimationComponent HeartPixelComponent
  {
    preset Bounds = <290,20,530,260>;
  }
}

$rect <230,360,430,400>
$output false
class HeartRateDisplayComponent : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,350,100>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <220,230,1000,550>;
  }

  $rect <20,20,160,60>
  object Views::Text TextHeartRate
  {
    preset Bounds = <0,0,170,100>;
    preset String = "-?-";
    preset Font = Application::HeartRateFont;
  }

  $rect <20,20,160,60>
  object Views::Text TextBPM
  {
    preset Bounds = <180,0,350,100>;
    preset String = "BPM";
    preset Font = Application::HeartRateFont;
  }

  $rect <10,170,210,210>
  method void SetBPM( arg int32 heartRate )
  {
    TextHeartRate.String = (string) heartRate;
  }
}

$rect <30,680,230,720>
$output false
resource Resources::Font HeartRateFont
{
  attr fontname FontName = Roboto;
  attr fontheight Height = 100;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
}

$rect <30,400,230,440>
$output false
class HeartAnimationComponent : Core::Group
{
  $rect <30,490,230,530>
  inherited property Bounds = <0,0,240,240>;

  $rect <30,650,230,690>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <30,610,230,650>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Image HeartImageBig
  {
    preset Bounds = <0,0,240,240>;
    preset Bitmap = Application::HeartPixelBig;
  }

  $rect <20,20,160,60>
  object Views::Image HeartImageSmall
  {
    preset Bounds = <0,0,240,240>;
    preset Bitmap = Application::HeartPixelSmall;
    preset Visible = false;
  }

  $rect <0,260,200,300>
  object Core::Timer HeartLongTimer
  {
    preset OnTrigger = HeartLongTimerSlot;
    preset Period = 0;
    preset Begin = 700;
    preset Enabled = true;
  }

  $rect <0,300,200,340>
  object Core::Timer HeartShortTimer
  {
    preset OnTrigger = HeartShortTimerSlot;
    preset Period = 0;
    preset Begin = 300;
  }

  $rect <230,260,430,300>
  slot HeartLongTimerSlot
  {
    sender; /* the method is called from the sender object */

    HeartImageBig.Visible = false;
    HeartImageSmall.Visible = true;

    HeartShortTimer.Enabled = true;
  }

  $rect <230,300,430,340>
  slot HeartShortTimerSlot
  {
    sender; /* the method is called from the sender object */

    HeartImageSmall.Visible = false;
    HeartImageBig.Visible = true;

    HeartLongTimer.Enabled = true;
  }
}

$rect <230,560,430,600>
$output false
resource Resources::Bitmap HeartPixelBig
{
  attr bitmapfile FileName = .\resources\heart_pixel_big.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <230,600,430,640>
$output false
resource Resources::Bitmap HeartPixelSmall
{
  attr bitmapfile FileName = .\resources\heart_pixel_small.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <230,640,430,680>
$output false
resource Resources::Bitmap Background
{
  attr bitmapfile FileName = .\resources\darkbg.jpg;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}
